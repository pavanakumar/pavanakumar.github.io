<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.55.6" />
  <meta name="author" content="Pavanakumar Mohanamuraly">

  
  
  
  
    
      
    
  
  <meta name="description" content="Abstract Fortran C/C&#43;&#43;/Python interoperability is an important consideration while designing scientific HPC codes. Fortran to a large extent still dominates in terms of lines of code in scientific software due to its legacy, reliable mathematical libraries and many years of research into the design of its compilers. Therefore it becomes mandatory to support an array of codes and libraries developed in mixed languages say Fortran, C and C&#43;&#43;. It is counter productive to rewrite the codes and revalidate just for the sake of using a single monolithic language.">

  
  <link rel="alternate" hreflang="en-us" href="http://pavanakumar.github.io/post/fortran-types/">

  


  

  
  
  <meta name="theme-color" content="#EF525B">
  
  
  
  
    
  
  
    
    
      
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
      
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  

  

  
  <link rel="alternate" href="http://pavanakumar.github.io/index.xml" type="application/rss+xml" title="Mohanamuraly">
  <link rel="feed" href="http://pavanakumar.github.io/index.xml" type="application/rss+xml" title="Mohanamuraly">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="http://pavanakumar.github.io/post/fortran-types/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="Mohanamuraly">
  <meta property="og:url" content="http://pavanakumar.github.io/post/fortran-types/">
  <meta property="og:title" content="Wrapping Fortran Derived Types : Part 1 | Mohanamuraly">
  <meta property="og:description" content="Abstract Fortran C/C&#43;&#43;/Python interoperability is an important consideration while designing scientific HPC codes. Fortran to a large extent still dominates in terms of lines of code in scientific software due to its legacy, reliable mathematical libraries and many years of research into the design of its compilers. Therefore it becomes mandatory to support an array of codes and libraries developed in mixed languages say Fortran, C and C&#43;&#43;. It is counter productive to rewrite the codes and revalidate just for the sake of using a single monolithic language.">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-05-23T00:53:26&#43;02:00">
  
  <meta property="article:modified_time" content="2019-05-23T00:53:26&#43;02:00">
  

  

  <title>Wrapping Fortran Derived Types : Part 1 | Mohanamuraly</title>

</head>
<body id="top" data-spy="scroll" data-target="#toc" data-offset="71" >

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/">Mohanamuraly</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      
      <ul class="nav navbar-nav navbar-right">
        

        

        
          
        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/#publications">
            
            <span>Publications</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/#projects">
            
            <span>Projects</span>
            
          </a>
        </li>

        
        
      

      
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <div class="article-inner">
      <h1 itemprop="name">Wrapping Fortran Derived Types : Part 1</h1>

      

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2019-05-23 00:53:26 &#43;0200 &#43;0200" itemprop="datePublished dateModified">
      May 23, 2019
    </time>
  </span>
  <span itemscope itemprop="author publisher" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Pavanakumar Mohanamuraly">
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    7 min read
  </span>
  

  
  

  
  
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Wrapping%20Fortran%20Derived%20Types%20%3a%20Part%201&amp;url=http%3a%2f%2fpavanakumar.github.io%2fpost%2ffortran-types%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=http%3a%2f%2fpavanakumar.github.io%2fpost%2ffortran-types%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fpavanakumar.github.io%2fpost%2ffortran-types%2f&amp;title=Wrapping%20Fortran%20Derived%20Types%20%3a%20Part%201"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=http%3a%2f%2fpavanakumar.github.io%2fpost%2ffortran-types%2f&amp;title=Wrapping%20Fortran%20Derived%20Types%20%3a%20Part%201"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Wrapping%20Fortran%20Derived%20Types%20%3a%20Part%201&amp;body=http%3a%2f%2fpavanakumar.github.io%2fpost%2ffortran-types%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>


      <div class="article-style" itemprop="articleBody">
        

<h2 id="abstract">Abstract</h2>

<p>Fortran C/C++/Python interoperability is an important consideration while designing scientific HPC codes. Fortran to a large extent still dominates in terms of lines of code in scientific software due to its legacy, reliable mathematical libraries and many years of research into the design of its compilers. Therefore it becomes mandatory to support an array of codes and libraries developed in mixed languages say Fortran, C and C++. It is counter productive to rewrite the codes and revalidate just for the sake of using a single monolithic language.</p>

<h2 id="some-shortcomings-of-iso-c-binding">Some shortcomings of <code>iso_c_binding</code></h2>

<p>The Fortran 2003 standard introduced the <code>iso_c_binding</code> module to formalise known C interoperability hacks into Fortran language. It still leaves out a dark area, namely wrapping user defined types when the type has allocatable or pointer attributes. A simple example is shown below:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">::</span> my_type
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">pointer</span> <span style="color:#66d9ef">::</span> my_data(:)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#66d9ef">end type </span>my_type</code></pre></div>

<p>Note that one could also include an allocatable array inside the user defined type such as:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">::</span> my_type
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">allocatable</span> <span style="color:#66d9ef">::</span> my_data(:)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#66d9ef">end type </span>my_type</code></pre></div>

<p>The user is advised against using this approach since this is not flexible enough to expose the data outside of Fortran because a pointer variable cannot be made to point to this target array <code>my_data</code> if it was declared <code>allocatable</code>. For the very reason the following piece of code is invalid:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">::</span> my_type
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">allocatable</span>, <span style="color:#66d9ef">target</span> <span style="color:#66d9ef">::</span> my_data(:)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#66d9ef">end type </span>my_type</code></pre></div>

<p>When compiled in <code>gfortran</code> one gets following error:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-linenos=inline" data-lang="linenos=inline">     real(c_double), allocatable, target :: my_data(:)
                                   1
Error: Attribute at (1) is not allowed in a TYPE definition</code></pre></div>

<p>Another approach one would be tempted to take is to use
the <code>bind(C)</code> technique from <code>iso_c_binding</code> as shown below:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">type</span>, <span style="color:#66d9ef">bind</span>(C) <span style="color:#66d9ef">::</span> my_type
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">allocatable</span>, <span style="color:#66d9ef">target</span> <span style="color:#66d9ef">::</span> my_data(:)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#66d9ef">end type </span>my_type</code></pre></div>

<p>But this results in a similar compiler error as the <code>target</code> approach:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-linenos=inline" data-lang="linenos=inline">   type, bind(C) :: my_type
                          2
     real(c_double), pointer :: my_data(:)
                                         1
Error: Component &#39;my_data&#39; at (1) cannot have the POINTER attribute because it is a member of the BIND(C) derived type &#39;my_type&#39; at (2)</code></pre></div>

<hr />

<h2 id="technique-1-opaque-object-handle-hack"><strong>Technique 1</strong>: Opaque object handle hack</h2>

<p>A famous trick employed by programmers to wrap user defined Fortran types into C is the use of scratch space handles or opaque objects. Simply put the C side allocates scratch space in memory (adequate enough to store the Fortran type) and pass that as a handle to Fortran. This handle can then be safely stored in the C side and passed around to Fortran functions to do computation. This has been give in detail in the work of <em>Pletzer et. al., &ldquo;Exposing Fortran derived types to C and other languages&rdquo;, comp. sci. eng. 2008</em>. The object storing the scratch memory is called the <strong>opaque object</strong> to the Fortran type.</p>

<p>The opaque object technique applied to our simple problem is shown below:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">! @file test.f90
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">! Fortran side code
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e"></span><span style="color:#66d9ef">module </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>  <span style="color:#66d9ef">use </span>iso_c_binding
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>  <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">::</span> my_type
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>    <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">pointer</span> <span style="color:#66d9ef">::</span> my_data(:)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>  <span style="color:#66d9ef">end type </span>my_type
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#66d9ef">end module </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">subroutine </span>c_opaque_alloc(c_obj, n)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>  <span style="color:#66d9ef">use </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>  <span style="color:#66d9ef">implicit none
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#66d9ef">  </span><span style="color:#66d9ef">integer</span>(<span style="color:#66d9ef">c_int</span>), <span style="color:#66d9ef">intent</span>(in) <span style="color:#66d9ef">::</span> n
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>  <span style="color:#66d9ef">type</span>(my_type) <span style="color:#66d9ef">::</span> c_obj
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>  <span style="color:#66d9ef">allocate</span>(c_obj%my_data(n))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span style="color:#66d9ef">end subroutine </span>c_opaque_alloc
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span style="color:#66d9ef">subroutine </span>c_opaque_free(c_obj)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>  <span style="color:#66d9ef">use </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>  <span style="color:#66d9ef">implicit none
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span style="color:#66d9ef">  type</span>(my_type) <span style="color:#66d9ef">::</span> c_obj
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span>  <span style="color:#66d9ef">deallocate</span>(c_obj%my_data)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span style="color:#66d9ef">end subroutine </span>c_opaque_free</code></pre></div>

<p>In the C side the following code is used to allocate the user defined type:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">/** @file test.c
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">  * C side code
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">  */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e">#define FC_GLOBAL_(name,NAME) name##_
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#75715e">#define OPAQUE_ALLOC FC_GLOBAL_(c_opaque_alloc, C_OPAQUE_ALLOC)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#75715e">#define OPAQUE_FREE FC_GLOBAL_(c_opaque_free, C_OPAQUE_FREE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#75715e">#define OPAQUE_STORAGE_SIZE 64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_ALLOC</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>n);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_FREE</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> nargs, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>args[] ) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>  <span style="color:#66d9ef">char</span> c_obj[OPAQUE_STORAGE_SIZE];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>  <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>  OPAQUE_ALLOC(c_obj, <span style="color:#f92672">&amp;</span>n);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>  OPAQUE_FREE(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>}</code></pre></div>

<p>The value of the <code>OPAQUE_STORAGE_SIZE</code> is an ambiguous one and varies from one compiler to another. Pletzer et. al. gives a long list of pointer array sizes used by various compilers based on their supported processor architecture. But the author does not give a reliable method to determine this size using existing Fortran features. This is one of the main contributions of this work where we provide a reliable method to obtain this size. Fortran 2008 standard defines a new inquiry function called <code>STORAGE_SIZE</code>. As per the standards <code>STORAGE_SIZE(A, [KIND])</code> returns a scalar integer with the kind type parameter specified by <code>KIND</code> (or default integer type if <code>KIND</code> is missing). The result value is the size expressed in bits for an element of an array that has the dynamic type and type parameters of <code>A</code>. Note that a dummy type <code>dummy_type</code> object was created in order to obtain the internal storage size in bits of this data structure. The routine would throw an error if one passed simple the <code>my_type</code>. Currently there does not seem to be a better way to avoid this dummy type creation.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">subroutine </span>c_storage_size( my_size )
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#66d9ef">use </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>  <span style="color:#66d9ef">implicit none
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#66d9ef">  type</span>(my_type) <span style="color:#66d9ef">::</span> dummy_obj
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>  <span style="color:#66d9ef">integer</span>(<span style="color:#66d9ef">c_int</span>) <span style="color:#66d9ef">::</span> my_size
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>  my_size <span style="color:#f92672">=</span> STORAGE_SIZE(dummy_obj, <span style="color:#66d9ef">c_int</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>  my_size <span style="color:#f92672">=</span> my_size <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span> <span style="color:#75715e">! return size in bytes
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#75715e"></span><span style="color:#66d9ef">end subroutine </span>c_storage_size</code></pre></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">#define FC_GLOBAL_(name,NAME) name##_
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">#define OPAQUE_ALLOC FC_GLOBAL_(c_opaque_alloc, C_OPAQUE_ALLOC)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">#define OPAQUE_FREE FC_GLOBAL_(c_opaque_free, C_OPAQUE_FREE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e">#define OPAQUE_SIZE FC_GLOBAL_(c_storage_size, C_STORAGE_SIZE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_ALLOC</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>n);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_FREE</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_SIZE</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> nargs, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>args[] ) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>  <span style="color:#66d9ef">int</span> my_size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>  OPAQUE_SIZE(<span style="color:#f92672">&amp;</span>my_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>  c_obj <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(my_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>  <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>  OPAQUE_ALLOC(c_obj, <span style="color:#f92672">&amp;</span>n);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>  OPAQUE_FREE(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>  free(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>}</code></pre></div>

<p>In addition, the contents of the types can be indirectly exposed to C using Fortran call back functions (Getter/Setter type). While such an approach can be good for scalar values it is inefficient for array types because two copies of the arrays
must exist in memory (one in the C side and the other in
the Fortran side). In addition, the data copy/move from one to the other is redundant. An example of this approach is provided nevertheless:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">subroutine </span>c_opaque_array_copy(c_obj, n, vec)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>  <span style="color:#66d9ef">use </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>  <span style="color:#66d9ef">implicit none
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#66d9ef">  type</span>(my_type) <span style="color:#66d9ef">::</span> c_obj
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>  <span style="color:#66d9ef">integer</span>(<span style="color:#66d9ef">c_int</span>), <span style="color:#66d9ef">intent</span>(in) <span style="color:#66d9ef">::</span> n
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>  <span style="color:#66d9ef">real</span>(<span style="color:#66d9ef">c_double</span>), <span style="color:#66d9ef">intent</span>(in) <span style="color:#66d9ef">::</span> vec(n)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>  <span style="color:#66d9ef">allocate</span>(c_obj%my_data(n))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>  c_obj%my_data(<span style="color:#ae81ff">1</span>:n) <span style="color:#f92672">=</span> vec(<span style="color:#ae81ff">1</span>:n)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>  <span style="color:#66d9ef">write</span>(<span style="color:#f92672">*</span>,<span style="color:#f92672">*</span>) c_obj%my_data
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">end subroutine </span>c_opaque_array_copy</code></pre></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">#define FC_GLOBAL_(name,NAME) name##_
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e">#define OPAQUE_ARRAY_COPY FC_GLOBAL_(c_opaque_array_copy, C_OPAQUE_ARRAY_COPY)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#75715e">#define OPAQUE_FREE FC_GLOBAL_(c_opaque_free, C_OPAQUE_FREE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#75715e">#define OPAQUE_SIZE FC_GLOBAL_(c_storage_size, C_STORAGE_SIZE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#75715e">#define SIZE 100
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_FREE</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_SIZE</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_ARRAY_COPY</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>n, <span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>vec);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> nargs, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>args[] ) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>  <span style="color:#66d9ef">int</span> my_size, i, n<span style="color:#f92672">=</span>SIZE;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>  <span style="color:#66d9ef">double</span> vec[SIZE];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>  <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>SIZE; <span style="color:#f92672">++</span>i) vec[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>  OPAQUE_SIZE(<span style="color:#f92672">&amp;</span>my_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>  c_obj <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(my_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span>  OPAQUE_ARRAY_COPY(c_obj, <span style="color:#f92672">&amp;</span>n, vec);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span>  OPAQUE_FREE(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>  free(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>}</code></pre></div>

<p>One can improve upon this recipe and also return handles to the arrays/scalars inside the opaque handle to avoid redundant storage. C can then use these array handles to access the array data without any redundant copy/move.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Fortran" data-lang="Fortran"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">subroutine </span>c_opaque_array(c_obj, c_array)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#66d9ef">use </span>typedef
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>  <span style="color:#66d9ef">implicit none
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#66d9ef">  type</span>(my_type) <span style="color:#66d9ef">::</span> c_obj
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>  <span style="color:#66d9ef">type</span>(<span style="color:#66d9ef">c_ptr</span>), <span style="color:#66d9ef">intent</span>(out) <span style="color:#66d9ef">::</span> c_array
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>  c_array <span style="color:#f92672">=</span> c_loc(c_obj%my_data(<span style="color:#ae81ff">1</span>))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#66d9ef">end subroutine </span>c_opaque_array</code></pre></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">#define FC_GLOBAL_(name,NAME) name##_
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">#define OPAQUE_ALLOC FC_GLOBAL_(c_opaque_alloc, C_OPAQUE_ALLOC)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">#define OPAQUE_ARRAY FC_GLOBAL_(c_opaque_array, C_OPAQUE_ARRAY)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e">#define OPAQUE_FREE FC_GLOBAL_(c_opaque_free, C_OPAQUE_FREE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#75715e">#define OPAQUE_SIZE FC_GLOBAL_(c_storage_size, C_STORAGE_SIZE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#75715e">#define SIZE 100
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_ALLOC</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>n);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_FREE</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_SIZE</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OPAQUE_ARRAY</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj, <span style="color:#66d9ef">double</span> <span style="color:#f92672">**</span>vec);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> nargs, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>args[] ) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c_obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>  <span style="color:#66d9ef">int</span> my_size, i, n<span style="color:#f92672">=</span>SIZE;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>  <span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>vec;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>  OPAQUE_SIZE(<span style="color:#f92672">&amp;</span>my_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>  c_obj <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(my_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>  OPAQUE_ALLOC(c_obj, <span style="color:#f92672">&amp;</span>n);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span>  OPAQUE_ARRAY(c_obj, <span style="color:#f92672">&amp;</span>vec);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span>  <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>SIZE; <span style="color:#f92672">++</span>i)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>    vec[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>  OPAQUE_FREE(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>  free(c_obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span>}</code></pre></div>

<p>While the <code>STORAGE_SIZE</code> primitive gave us a portable and safe solution to wrap user defined types, some older Fortran compiler might not support the Fortran 2008 standards yet. In such situations one should resort to an alternative approach using <code>TRANSFER</code> which will be presented in the second part of this work.</p>

<p><em>Access to the source code with Makefiles to be uploaded soon to GitHub after testing against Intel, GCC, PGI, and LLVM compilers.</em></p>

      </div>

      




    </div>
  </div>

</article>






<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; Pavanakumar Mohanamuraly, 2019 &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    

    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    

  </body>
</html>

